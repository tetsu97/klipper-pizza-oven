// /static/js/pages/profiles.js (refactor)
// Stránka Profiles: seznam + Create (generator) + Edit (editor)
//
// Cíle refactoru:
// - odstranit duplikace "gen*/edit*" => sdílené komponenty (SegmentsTable, ChartView, Modal)
// - jasné API volání v ProfilesService
// - thumbnails + ORCA header v izolovaných utilitách
// - zachovat stejné ID prvků a stejné endpointy, aby nebyla nutná změna HTML/CSS ani backendu

(function () {
  if (!location.pathname.startsWith('/profiles')) return;

  // ====== Mini helpers ======
  const $  = (sel, ctx=document) => ctx.querySelector(sel);
  const $$ = (sel, ctx=document) => Array.from(ctx.querySelectorAll(sel));
  const clampNum = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
  const toInt = (v, d=0) => { const n = parseInt(v, 10); return Number.isFinite(n) ? n : d; };

  const humanSize = (bytes) => {
    if (bytes == null) return "—";
    if (bytes < 1024) return `${bytes} B`;
    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} kB`;
    return `${(bytes / 1024 / 1024).toFixed(2)} MB`;
  };
  const humanTime = (ts) => { try { return new Date(ts*1000).toLocaleString(); } catch { return "—"; } };

  // ====== ORCA header & Thumbnails (stejná funkcionalita, čisté utilitky) ======
  const Orca = {
    buildHeader(date=new Date()) {
      const pad = (n)=>String(n).padStart(2,'0');
      const yyyy=date.getFullYear(), mm=pad(date.getMonth()+1), dd=pad(date.getDate());
      const hh=pad(date.getHours()), mi=pad(date.getMinutes()), ss=pad(date.getSeconds());
      return `; generated by Klipper_PIZZA_Oven on ${yyyy}-${mm}-${dd} at ${hh}:${mi}:${ss}`;
    },
    hasHeader(g) {
      return /^\s*; generated by (?:OrcaSlicer 2\.3\.0|Klipper_PIZZA_Oven) /m.test(g||'');
    },
    stripHeaderAndThumbs(text) {
      if (!text) return '';
      let out = String(text);
      out = out.replace(/^\s*; generated by (?:OrcaSlicer 2\.3\.0|Klipper_PIZZA_Oven) .*\n?/, '');
      out = out.replace(/^\s*; THUMBNAIL_BLOCK_START\s*\n?/gmi, '');
      out = out.replace(/^\s*; THUMBNAIL_BLOCK_END\s*\n?/gmi, '');
      out = out.replace(/(^|\n);[ ]*thumbnail begin[^\n]*\n(?:;.*\n)+?;[ ]*thumbnail end[^\n]*\n?/gi,'$1');
      return out.trimStart();
    },
  };

  const Thumbs = {
    _pngLen(b64){ try { return atob(b64).length; } catch { return 0; } },
    _squareFromCanvas(srcCanvas, size, bg='#121527') {
      if (!srcCanvas) return '';
      const out = document.createElement('canvas');
      out.width = out.height = size;
      const ctx = out.getContext('2d');
      ctx.fillStyle = bg; ctx.fillRect(0,0,size,size);
      const sw = srcCanvas.width  || Math.round(srcCanvas.getBoundingClientRect().width  * (window.devicePixelRatio||1));
      const sh = srcCanvas.height || Math.round(srcCanvas.getBoundingClientRect().height * (window.devicePixelRatio||1));
      if (!sw || !sh) return '';
      const scale = Math.max(size/sw, size/sh); // cover
      const dw = Math.round(sw*scale), dh = Math.round(sh*scale);
      const dx = Math.floor((size-dw)/2), dy = Math.floor((size-dh)/2);
      ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality='high';
      ctx.drawImage(srcCanvas, dx, dy, dw, dh);
      return (out.toDataURL('image/png').split(',')[1]||'').trim();
    },
    _sizedFromCanvas(srcCanvas, w, h, bg='#121527', mode='cover') {
      if (!srcCanvas) return '';
      const out = document.createElement('canvas'); out.width=w; out.height=h;
      const ctx = out.getContext('2d');
      ctx.fillStyle = bg; ctx.fillRect(0,0,w,h);
      const sw = srcCanvas.width  || Math.round(srcCanvas.getBoundingClientRect().width  * (window.devicePixelRatio||1));
      const sh = srcCanvas.height || Math.round(srcCanvas.getBoundingClientRect().height * (window.devicePixelRatio||1));
      if (!sw || !sh) return '';
      let dw,dh,dx,dy;
      if (mode==='contain') {
        const s = Math.min(w/sw, h/sh); dw=Math.round(sw*s); dh=Math.round(sh*s);
        dx=Math.floor((w-dw)/2); dy=Math.floor((h-dh)/2);
      } else {
        const s = Math.max(w/sw, h/sh); dw=Math.round(sw*s); dh=Math.round(sh*s);
        dx=Math.floor((w-dw)/2); dy=Math.floor((h-dh)/2);
      }
      ctx.imageSmoothingEnabled=true; ctx.imageSmoothingQuality='high';
      ctx.drawImage(srcCanvas, dx, dy, dw, dh);
      return (out.toDataURL('image/png').split(',')[1]||'').trim();
    },
    _makeBlock(b64, w, h) {
      if (!b64) return '';
      const byteLen = Thumbs._pngLen(b64);
      const lines = [`; thumbnail begin ${w}x${h} ${byteLen}`];
      for (let i=0;i<b64.length;i+=76) lines.push(`; ${b64.slice(i,i+76)}`);
      lines.push(`; thumbnail end`);
      return lines.join('\n');
    },
    buildBlocks() {
      const c = document.getElementById('chart');
      if (!c) return [];
      const out = [];
      const s48 = Thumbs._squareFromCanvas(c,48);  if (s48)  out.push(Thumbs._makeBlock(s48,48,48));
      const s300= Thumbs._squareFromCanvas(c,300); if (s300) out.push(Thumbs._makeBlock(s300,300,300));
      const w480= Thumbs._sizedFromCanvas(c,480,270,'#121527','cover'); if (w480) out.push(Thumbs._makeBlock(w480,480,270));
      return out;
    },
    extractMapFromGcode(text) {
      const map = {};
      if (!text) return map;
      const lines = String(text).split(/\r?\n/);
      const beginRe = /^\s*;\s*thumbnail begin\s+(\d+)x(\d+)\s+(\d+)/i;
      const endRe   = /^\s*;\s*thumbnail end\b/i;
      let capturing=false, curW=0, curH=0, buf=[];
      for (const raw of lines) {
        const line=raw||'';
        if (!capturing) {
          const m=line.match(beginRe);
          if (m){ curW=+m[1]; curH=+m[2]; buf=[]; capturing=true; }
          continue;
        } else {
          if (endRe.test(line)) {
            const k=`${curW}x${curH}`; const b64=buf.join('').replace(/\s+/g,'');
            if (b64) map[k]=b64;
            capturing=false; curW=curH=0; buf=[];
            continue;
          }
          const payload=line.replace(/^\s*;\s?/,'').trim();
          if (payload && /^[A-Za-z0-9+/=]+$/.test(payload)) buf.push(payload);
        }
      }
      return map;
    },
    async fetchThumbDataURL(name) {
      try {
        const r = await fetch(`/api/gcodes/download?name=${encodeURIComponent(name)}`, { cache:'no-store' });
        if (!r.ok) return null;
        const text = await r.text();
        const thumbs = Thumbs.extractMapFromGcode(text);
        const order = ['480x270','300x300','48x48','32x32'];
        const key = order.find(k => thumbs[k]);
        return key ? `data:image/png;base64,${thumbs[key]}` : null;
      } catch { return null; }
    },
  };

  // ====== Body/Segments konverze – sdílené pro Generate i Edit (dříve duplikace) ======
  // (původně existovaly dvojí varianty pro generator i editor – teď jediný zdroj pravdy )
  const ProfileMath = {
    dedupePoints(points) {
      const pts = (points||[])
        .map(p=>({time:+p.time||0, temp:+p.temp||0}))
        .sort((a,b)=>a.time-b.time);
      if (pts.length<=1) return pts;
      const out=[pts[0]];
      for (let i=1;i<pts.length;i++){
        const p=pts[i], last=out[out.length-1];
        if (p.time===last.time && p.temp===last.temp) continue;
        if (p.time===last.time) { out[out.length-1]=p; continue; }
        const prev=out[out.length-2];
        if (prev){
          const dx1=last.time-prev.time, dy1=last.temp-prev.temp;
          const dx2=p.time-last.time,   dy2=p.temp-last.temp;
          if (dy1===0 && dy2===0) { out[out.length-1]=p; continue; }
          if (dx1!==0 && dx2!==0){
            const s1=dy1/dx1, s2=dy2/dx2;
            if (Math.abs(s1-s2)<1e-9) { out[out.length-1]=p; continue; }
          }
        }
        out.push(p);
      }
      return out;
    },
    pointsToSegments(points) {
      const pts=(points||[]).map(p=>({time:+p.time||0,temp:+p.temp||0})).sort((a,b)=>a.time-b.time);
      const segs=[];
      for (let i=0;i<pts.length-1;i++){
        const from=pts[i].time, to=pts[i+1].time, temp=pts[i+1].temp;
        if (to-from>0) segs.push({from,to,temp});
      }
      return segs;
    },
    segmentsToPoints(segments, startTemp) {
      const segs=(segments||[]).map(s=>({from:+s.from||0,to:+s.to||0,temp:+s.temp||0}))
        .filter(s=>s.to>s.from).sort((a,b)=>a.from-b.from);
      const pts=[];
      const first=(typeof startTemp==='number')?startTemp:(segs[0]?segs[0].temp:0);
      pts.push({time:0, temp:first});
      let t=0;
      for (const s of segs){
        if (s.from>t) pts.push({time:s.from, temp:pts[pts.length-1].temp});
        pts.push({time:s.to, temp:s.temp});
        t=s.to;
      }
      return pts;
    },
    dedupeSegments(segments) {
      const sorted=(segments||[])
        .map(s=>({from:+s.from||0,to:+s.to||0,temp:+s.temp||0}))
        .filter(s=>s.to>s.from)
        .sort((a,b)=>(a.from-b.from)||(a.to-b.to)||(a.temp-b.temp));
      const out=[];
      for (const s of sorted){
        const last=out[out.length-1];
        if (last && last.from===s.from && last.to===s.to && last.temp===s.temp) continue;
        if (last && last.to===s.from && last.temp===s.temp){ last.to=s.to; continue; }
        out.push({...s});
      }
      return out;
    },
    pointsToSegmentsForTable(points){
      const clean = ProfileMath.dedupePoints(points||[]);
      const segs  = ProfileMath.pointsToSegments(clean);
      return ProfileMath.dedupeSegments(segs);
    }
  };

  // ====== Komponenty UI ======
  class Modal {
    constructor(rootId) { this.root = document.getElementById(rootId); }
    open(){ if (this.root){ this.root.style.display='flex'; } }
    close(){ if (this.root){ this.root.style.display='none'; } }
    static lockBackdrop(ids=['generatorModal','editModal']){
      ids.forEach(id=>{
        const m=document.getElementById(id);
        if (!m) return;
        m.addEventListener('click',(e)=>{ if (e.target===m){ e.preventDefault(); e.stopImmediatePropagation(); } }, true);
      });
      window.addEventListener('keydown',(e)=>{
        if (e.key!=='Escape') return;
        const anyOpen = ids.some(id=>{
          const el = document.getElementById(id);
          return el && (el.style.display==='flex' || el.style.display==='block');
        });
        if (anyOpen){ e.preventDefault(); e.stopImmediatePropagation(); }
      }, true);
    }
  }

  class ChartView {
    constructor(canvasSel){ this.canvasSel = canvasSel; this.chart = null; }
    _ctx(){ const c=$(this.canvasSel); return c? c.getContext('2d') : null; }
    destroy(){ try{ this.chart?.destroy(); }catch{} this.chart=null; }
    render(points, {dedupe=true}={}){
      const ctx=this._ctx(); if (!ctx) return;
      const src = dedupe ? ProfileMath.dedupePoints(points||[]) : (points||[]);
      const labels = src.map(p=>p.time);
      const temps  = src.map(p=>p.temp);
      if (this.chart) this.chart.destroy();
      this.chart = new Chart(ctx, {
        type:'line',
        data:{ labels, datasets:[{ label:'Temperature (°C)', data:temps, borderColor:'#f44336',
          backgroundColor:'rgba(244,67,54,.2)', tension:.1, pointRadius:6, pointBackgroundColor:'#f44336', fill:true }] },
        options:{ responsive:true, maintainAspectRatio:false, plugins:{ legend:{ labels:{ color:'#fff' } } },
          scales:{ x:{ ticks:{color:'#fff'}, title:{display:true,text:'Time (min)',color:'#fff'} },
                   y:{ ticks:{color:'#fff'}, title:{display:true,text:'Temperature (°C)',color:'#fff'} } } }
      });
      requestAnimationFrame(()=>{ try{ this.chart.resize(); }catch{} });
    }
  }

  class SegmentsTable {
    constructor(tbodySel, onChange){
      this.tbody = document.querySelector(tbodySel);
      this.onChange = onChange;
      this._bind();
    }
    _bind(){
      if (!this.tbody) return;
      this.tbody.addEventListener('click', (e)=>{
        const del = e.target.closest('.row-del');
        if (del){ del.closest('tr')?.remove(); this.onChange?.(); }
      });
      this.tbody.addEventListener('input', ()=> this.onChange?.());
    }
    load(segments){
      if (!this.tbody) return;
      this.tbody.innerHTML='';
      (segments||[]).forEach(s=>{
        const tr=document.createElement('tr');
        tr.innerHTML = `
          <td><input type="number" value="${s.from}" step="1" style="width:90px"></td>
          <td><input type="number" value="${s.to}"   step="1" style="width:90px"></td>
          <td><input type="number" value="${s.temp}" step="1" style="width:90px"></td>
          <td><button class="row-del">Delete</button></td>`;
        this.tbody.appendChild(tr);
      });
    }
    addRow(defaults={}) {
      if (!this.tbody) return;
      const last = this.tbody.lastElementChild;
      const lastTo   = last ? parseInt(last.cells[1].querySelector('input').value,10) || 0 : 0;
      const lastTemp = last ? parseInt(last.cells[2].querySelector('input').value,10) || 20 : 20;
      const from = defaults.from ?? lastTo;
      const to   = defaults.to   ?? (lastTo+60);
      const temp = defaults.temp ?? lastTemp;
      const tr=document.createElement('tr');
      tr.innerHTML = `
        <td><input type="number" value="${from}" step="1" style="width:90px"></td>
        <td><input type="number" value="${to}"   step="1" style="width:90px"></td>
        <td><input type="number" value="${temp}" step="1" style="width:90px"></td>
        <td><button class="row-del">Delete</button></td>`;
      this.tbody.appendChild(tr);
      this.onChange?.();
    }
    read(){
      if (!this.tbody) return [];
      const segs = [];
      // ✅ žádné skládání selektoru, prostě vezmi <tr> z tbody
      this.tbody.querySelectorAll('tr').forEach(tr=>{
        const from = parseInt(tr.cells[0].querySelector('input').value,10) || 0;
        const to   = parseInt(tr.cells[1].querySelector('input').value,10) || 0;
        const temp = parseInt(tr.cells[2].querySelector('input').value,10) || 0;
        if (to > from) segs.push({from,to,temp});
      });
      return segs.sort((a,b)=>a.from-b.from);
    }
    clear(){ if (this.tbody) this.tbody.innerHTML=''; }
  }

  // ====== API layer ======
  const ProfilesService = {
    async list(){ const r=await fetch('/api/gcodes',{cache:'no-store'}); if(!r.ok) throw new Error('HTTP '+r.status); return r.json(); },
    async start(name){ const r=await fetch(`/api/gcodes/start?name=${encodeURIComponent(name)}`,{method:'POST'}); if(!r.ok) throw new Error('HTTP '+r.status); return r.json(); },
    async download(name){ window.open(`/api/gcodes/download?name=${encodeURIComponent(name)}`,'_blank'); },
    async remove(name){ const r=await fetch(`/api/gcodes?name=${encodeURIComponent(name)}`,{method:'DELETE'}); if(!r.ok) throw new Error('HTTP '+r.status); },
    async load(name){ const r=await fetch(`/api/gcodes/load?name=${encodeURIComponent(name)}`,{cache:'no-store'}); if(!r.ok) throw new Error('HTTP '+r.status); return r.json(); },
    async generate(payload){
      const r=await fetch('/api/generate_gcode',{method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify(payload)});
      if (!r.ok) throw new Error(`HTTP ${r.status}: ${await r.text()}`); return r.json();
    },
    async saveToKlipper(filename, gcode){
      const r=await fetch('/api/save_gcode',{method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({filename,gcode})});
      if (!r.ok) throw new Error('HTTP '+r.status+' '+await r.text()); return r.json();
    },
    async saveEdited(name, program_name, filament_type, points){
      const r=await fetch('/api/gcodes/save',{method:'POST', headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ name, program_name, filament_type, mode:'annealing', points, overwrite:true })});
      if (!r.ok) throw new Error('HTTP '+r.status); return r.json();
    },
  };

  // ====== Generator (Create) Controller ======
  class GeneratorController {
    constructor(){
      this.modal = new Modal('generatorModal');
      this.chart = new ChartView('#chart');
      this.mode  = 'annealing';
      this.segTable = new SegmentsTable('#genSegmentsTable tbody', ()=>this._onSegmentsChanged());
      this._bind();
    }
    _bind(){
      $('#genAddSegmentBtn')?.addEventListener('click', ()=> this.segTable.addRow());
      $('#genGenerateBtn')?.addEventListener('click', ()=> this.generate());
      $('#genDownloadBtn')?.addEventListener('click', ()=> this.download());
      $('#genSaveBtn')?.addEventListener('click', ()=> this.saveToKlipper());
      $('#genCloseBtn')?.addEventListener('click', ()=> this.modal.close());
      $('#openGeneratorBtn')?.addEventListener('click', ()=>{
        this.open(); this.setMode('annealing'); requestAnimationFrame(()=>{ try{ this.chart.chart?.resize(); }catch{} });
      });
      $('#btn-annealing')?.addEventListener('click', ()=> this.setMode('annealing'));
      $('#btn-drying')?.addEventListener('click',    ()=> this.setMode('drying'));
    }
    open(){ this.modal.open(); }
    close(){ this.modal.close(); }
    setMode(mode){
      this.mode = mode;
      const drying = $('#dryingInputs'); const anneal = $('#annealingInputs');
      const bA = $('#btn-annealing'); const bD = $('#btn-drying');
      if (mode==='annealing'){
        drying && (drying.style.display='none');
        anneal && (anneal.style.display='block');
        bA?.classList.add('active'); bD?.classList.remove('active');
        // defaultní demo
        this.segTable.load([
          { from:0, to:60, temp:80 },
          { from:120, to:180, temp:120 },
          { from:780, to:960, temp:50 }
        ]);
        this._renderFromTable(0);
      } else {
        drying && (drying.style.display='block');
        anneal && (anneal.style.display='none');
        bA?.classList.remove('active'); bD?.classList.add('active');
        this.segTable.clear();
        const tEl=$('#dryingTime'); if (tEl) tEl.value = 300;
        const tempEl=$('#dryingTemp'); if (tempEl) tempEl.value = 60;
        this.chart.destroy();
      }
    }
    _onSegmentsChanged(){ this._renderFromTable(0); }
    _renderFromTable(startTemp){
      const segs=this.segTable.read();
      const pts=ProfileMath.segmentsToPoints(segs, startTemp);
      this.chart.render(pts, {dedupe:true});
    }
    _buildFileName(){
      const name = ($('#programName')?.value.trim()) || 'program';
      const safe = name.replace(/\s+/g,'_').replace(/[^\w\-\.]/g,'');
      let totalMinutes = 0;
      if (this.mode==='annealing' && this.chart.chart?.data?.labels?.length>=2) {
        const times = this.chart.chart.data.labels.map(Number).sort((a,b)=>a-b);
        totalMinutes = times[times.length-1]-times[0];
      } else if (this.mode==='drying') {
        totalMinutes = toInt($('#dryingTime')?.value||'0', 0);
      }
      const h=Math.floor(totalMinutes/60), m=totalMinutes%60;
      const suffixTime = h>0 ? (m>0?`_${h}h${m}m`:`_${h}h`) : `_${m}m`;
      const suffixMode = this.mode==='drying' ? '_drying' : '_annealing';
      return `${safe}${suffixMode}${suffixTime}.gcode`;
    }
    async generate(){
      const programName = $('#programName')?.value.trim() || 'Program';
      const filamentType = $('#filamentType')?.value.trim() || '';
      const payload = { program_name: programName, filament_type: filamentType, mode:this.mode, points:[], drying_time:null, drying_temp:null };
      if (this.mode==='annealing') {
        const segs=this.segTable.read();
        payload.points = ProfileMath.segmentsToPoints(segs, 0);
      } else {
        payload.drying_time = toInt($('#dryingTime')?.value, 0);
        payload.drying_temp = toInt($('#dryingTemp')?.value, 0);
      }
      try {
        const res = await ProfilesService.generate(payload);
        const base = (res.gcode||'').trimStart();
        const START='; THUMBNAIL_BLOCK_START', END='; THUMBNAIL_BLOCK_END';
        const header = Orca.buildHeader();
        const blocks = Thumbs.buildBlocks();
        const body = Orca.stripHeaderAndThumbs(base);
        const withThumbs = blocks.length ? (blocks.map(b=>`${START}\n;\n${b}\n${END}`).join('\n')+'\n') : '';
        const finalGcode = `${header}\n${withThumbs}${body}`;
        $('#gcodeOutput').value = finalGcode;
        Toast.show("G-code vygenerován.", 'info');
      } catch (e) {
        console.error(e);
        Toast.show('Generování G-code selhalo: '+e.message, 'error');
        $('#gcodeOutput').value='';;
      }
    }
    download(){
      let gcode = $('#gcodeOutput')?.value || '';
      if (!gcode.trim()) {
        Toast.show('Nejdřív vygeneruj G-code.', 'info');
        return;
      }
      const START='; THUMBNAIL_BLOCK_START', END='; THUMBNAIL_BLOCK_END';
      const header=Orca.buildHeader();
      const body = Orca.stripHeaderAndThumbs(gcode);
      const blocks = Thumbs.buildBlocks();
      const withThumbs = blocks.length ? (blocks.map(b=>`${START}\n;\n${b}\n${END}`).join('\n')+'\n') : '';
      const final = `${header}\n${withThumbs}${body}`;
      const filename = this._buildFileName();
      const blob = new Blob([final], {type:'text/plain'});
      const a=document.createElement('a'); a.download=filename; a.href=URL.createObjectURL(blob); a.click(); URL.revokeObjectURL(a.href);
    }
    async saveToKlipper(){
      let gcode = $('#gcodeOutput')?.value || "";
      if (!gcode.trim()) {
        Toast.show('Nejdřív vygeneruj G-code.', 'info');
        return;
      }
      const START='; THUMBNAIL_BLOCK_START', END='; THUMBNAIL_BLOCK_END';
      const header=Orca.buildHeader();
      const body = Orca.stripHeaderAndThumbs(gcode);
      const blocks = Thumbs.buildBlocks();
      const withThumbs = blocks.length ? (blocks.map(b=>`${START}\n;\n${b}\n${END}`).join('\n')+'\n') : '';
      const final = `${header}\n${withThumbs}${body}`;
      const filename = this._buildFileName();
      try {
        const r = await ProfilesService.saveToKlipper(filename, final);
        if (r?.ok){
          Toast.show('Uloženo jako: '+r.filename, 'success');
          this.close();
          await ProfilesPage.loadList();
        } else {
          Toast.show('Neznámá odpověď serveru.', 'error');
        }
      } catch(e){
        console.error(e);
        Toast.show('Ukládání selhalo: '+e.message, 'error');
      }
    }
  }

  // ====== Editor Controller ======
  class EditorController {
    constructor() {
      this.modal = new Modal('editModal');
      this.chart = new ChartView('#editPointsChart');
      this.segTable = new SegmentsTable('#segmentsTable tbody', null); // onChange už nepotřebujeme
      this.currentFile = null;
      this.startTemp = 0;

      // Datový model - jediný zdroj pravdy
      this.rawSegments = [];
      // Mapa pro propojení zobrazených řádků na surová data
      this.cleanToRawMap = [];

      // Nová, chytřejší obsluha událostí
      this.tbody = $('#segmentsTable tbody');
      this.tbody?.addEventListener('input', this._handleTableInput.bind(this));

      $('#editAddSegmentBtn')?.addEventListener('click', () => this.addSegment());
      $('#editSaveBtn')?.addEventListener('click', () => this.save());
      $('#editCancelBtn')?.addEventListener('click', () => this.modal.close());
      $('#editCloseBtn')?.addEventListener('click', () => this.modal.close());
    }

    // Nová metoda pro synchronizaci všeho (tabulka + graf) z datového modelu
    _syncUIFromState() {
      if (!this.tbody) return;

      // 1. Vytvoříme zjednodušené segmenty pro zobrazení
      const cleanSegments = ProfileMath.dedupeSegments(this.rawSegments);

      // 2. Vytvoříme mapu mezi zjednodušenými a surovými segmenty
      this.cleanToRawMap = [];
      let rawIndex = 0;
      for (const clean of cleanSegments) {
          const rawIndices = [];
          while (rawIndex < this.rawSegments.length && this.rawSegments[rawIndex].to <= clean.to) {
              rawIndices.push(rawIndex);
              rawIndex++;
          }
          this.cleanToRawMap.push(rawIndices);
      }

      // 3. Vykreslíme zjednodušenou tabulku a označíme řádky
      this.segTable.load(cleanSegments);
      this.tbody.querySelectorAll('tr').forEach((tr, i) => tr.dataset.cleanIndex = i);
      
      // 4. Vykreslíme graf z kompletních, surových dat
      const pts = ProfileMath.segmentsToPoints(this.rawSegments, this.startTemp);
      this.chart.render(pts, { dedupe: false });
    }

    // Nová metoda pro zpracování změn v tabulce
    _handleTableInput(e) {
      const tr = e.target.closest('tr');
      if (!tr) return;

      const cleanIndex = parseInt(tr.dataset.cleanIndex, 10);
      const rawIndices = this.cleanToRawMap[cleanIndex];
      if (!rawIndices || rawIndices.length === 0) return;

      // Přečteme nové hodnoty z řádku
      const newCleanValues = {
          from: parseInt(tr.cells[0].querySelector('input').value, 10) || 0,
          to:   parseInt(tr.cells[1].querySelector('input').value, 10) || 0,
          temp: parseInt(tr.cells[2].querySelector('input').value, 10) || 0,
      };

      // Získáme původní surové segmenty, které tento řádek reprezentuje
      const originalRawSegments = rawIndices.map(i => this.rawSegments[i]);

      // Aplikujeme změny na ně
      const updatedRawSegments = ProfileMath.applyCleanSegmentChange(originalRawSegments, newCleanValues);

      // Nahradíme staré surové segmenty novými v našem hlavním modelu
      this.rawSegments.splice(rawIndices[0], rawIndices.length, ...updatedRawSegments);

      // Znovu vše synchronizujeme
      this._syncUIFromState();
    }
    
    addSegment() {
        const lastSeg = this.rawSegments[this.rawSegments.length - 1] || { to: 0, temp: 20 };
        const newTemp = Math.min(300, lastSeg.temp + 20); // Zvýšíme teplotu o 20°C, max 300°C

        this.rawSegments.push({ from: lastSeg.to, to: lastSeg.to + 60, temp: newTemp });
        this._syncUIFromState();
    }

    async openFor(name) {
      try {
        const data = await ProfilesService.load(name);
        this.currentFile = name;
        this.modal.open();
        
        $('#editProgramName').value = data.program_name || '';
        $('#editFilamentType').value = data.filament_type || '';

        const rawPts = Array.isArray(data.points)
          ? data.points.map(p => ({ time: +p.time || 0, temp: +p.temp || 0 })).sort((a, b) => a.time - b.time)
          : [];
        
        this.startTemp = rawPts[0]?.temp ?? 0;
        // Vytvoříme náš zdroj pravdy - surové segmenty
        this.rawSegments = ProfileMath.pointsToSegments(rawPts);
        
        // A synchronizujeme zobrazení
        setTimeout(() => this._syncUIFromState(), 0);

      } catch (e) {
        console.error(e);
        alert('Nepodařilo se načíst program.');
      }
    }

    async save() {
      if (!this.currentFile) {
        Toast.show('Není vybraný soubor.', 'info');
        return;
      }
      
      // Pro uložení použijeme data z našeho modelu, ne z tabulky
      const pts = ProfileMath.dedupePoints(ProfileMath.segmentsToPoints(this.rawSegments, this.startTemp));
      if (!Array.isArray(pts) || pts.length < 2) {
        Toast.show('Přidej alespoň dva body profilu.', 'info');
        return;
      }
      const programName = $('#editProgramName').value.trim();
      const filamentType = $('#editFilamentType').value.trim();
      
            try {
        const res = await ProfilesService.saveEdited(this.currentFile, programName, filamentType, pts);
        if ((res && res.ok === true) || res.status === "ok") {
          Toast.show('Program uložen.', 'success');
          this.modal.close();
          await ProfilesPage.loadList();
        } else {
          Toast.show('Chyba při ukládání.', 'error');
        }
      } catch (e) {
        console.error(e);
        Toast.show('Chyba při komunikaci se serverem.', 'error');
      }
    }
  }

  // ====== Stránka Profiles (seznam a akce) ======
  const ProfilesPage = {
    gen: null,
    edit: null,
    contextMenu: null,

      async loadList() {
        const tbody = $('#profilesTable tbody');
        if (!tbody) return;
        tbody.innerHTML = '<tr><td colspan="5" style="text-align:center;opacity:.7;">Loading…</td></tr>';
        try {
          const data = await ProfilesService.list();
          const files = (data && data.files) || [];
          tbody.innerHTML = '';
          for (const f of files) {
            const tr = document.createElement('tr');
            tr.setAttribute('data-name', f.name);
            tr.classList.add('clickable-row');
            tr.innerHTML = `
              <td class="name-cell" data-label="Name">
                <img class="gthumb" alt="thumb" />
                <span class="fname">${f.name}</span>
              </td>
              <td data-label="File size">${humanSize(f.size)}</td>
              <td data-label="Last modified">${humanTime(f.mtime)}</td>
              <td data-label="Filament">${f.filament_type || '-'}</td>`;
            tbody.appendChild(tr);
            ProfilesPage._loadThumb(f.name, tr.querySelector('img.gthumb'));
          }
        } catch (e) {
          console.error(e);
          tbody.innerHTML = '<tr><td colspan="5" style="text-align:center;color:#f55;">Failed to load.</td></tr>';
        }
      },

    async _loadThumb(name, imgEl) {
      if (!imgEl) return;
      imgEl.src = ''; imgEl.style.opacity = '0';
      const url = await Thumbs.fetchThumbDataURL(name);
      if (url) { imgEl.src = url; imgEl.style.opacity = '1'; }
    },
  
    _createContextMenu() {
      if (document.getElementById('profilesContextMenu')) return;
      const menu = document.createElement('ul');
      menu.id = 'profilesContextMenu';
      menu.className = 'context-menu';
      menu.innerHTML = `
        <li><button data-act="start">Start</button></li>
        <li><button data-act="edit">Edit</button></li>
        <li><button data-act="download">Download</button></li>
        <li><button data-act="delete" class="btn--danger">Delete</button></li>
      `;
      document.body.appendChild(menu);
      this.contextMenu = menu;

      // Kliknutí na akci v menu
      menu.addEventListener('click', async (e) => {
        const button = e.target.closest('button');
        if (!button) return;
        const act = button.dataset.act;
        const name = menu.dataset.fileName;
        if (!act || !name) return;
        
        this._handleAction(act, name);
        this._hideContextMenu();
      });
    },

    _showContextMenu(event, fileName) {
      this.contextMenu.dataset.fileName = fileName;
      this.contextMenu.style.display = 'block';
      this.contextMenu.style.left = `${event.pageX}px`;
      this.contextMenu.style.top = `${event.pageY}px`;
    },

    _hideContextMenu() {
      if (this.contextMenu) {
        this.contextMenu.style.display = 'none';
      }
    },

    async _handleAction(act, name) {
      try {
        if (act === 'start') {
          // Toto teď řeší globální modální okno, takže zde nic neděláme
        } else if (act === 'download') {
          ProfilesService.download(name);
        } else if (act === 'delete') {
          if (!confirm(`Opravdu smazat: ${name}?`)) return;
          await ProfilesService.remove(name);
          Toast.show(`Soubor ${name} smazán.`, 'success');
          await ProfilesPage.loadList();
        } else if (act === 'edit') {
          await ProfilesPage.edit.openFor(name);
        }
      } catch (err) {
        console.error(err);
        Toast.show('Akce selhala: ' + (err?.message || err), 'error');
      }
    },

    bind() {
      $('#profilesRefreshBtn')?.addEventListener('click', () => ProfilesPage.loadList());
      
      const tbody = $('#profilesTable tbody');
      if (!tbody) return;

      // Detekce, jestli se jedná o dotykové zařízení
      const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

      if (isTouchDevice) {
        // --- CHOVÁNÍ PRO MOBILNÍ ZAŘÍZENÍ ---
        // Obyčejné klepnutí (click) otevře kontextové menu
        tbody.addEventListener('click', (e) => {
          const row = e.target.closest('tr.clickable-row');
          if (row) {
            e.stopPropagation(); // Zabráníme nechtěnému zavření menu
            const name = row.dataset.name;
            this._showContextMenu(e, name);
          }
        });
      } else {
        // --- PŮVODNÍ CHOVÁNÍ PRO POČÍTAČ S MYŠÍ ---
        // Levý klik otevře "Start" modální okno
        tbody.addEventListener('click', (e) => {
          const row = e.target.closest('tr.clickable-row');
          if (row) {
            const name = row.dataset.name;
            StartJobModal.open(name);
          }
        });

        // Pravý klik otevře kontextové menu
        tbody.addEventListener('contextmenu', (e) => {
          e.preventDefault();
          const row = e.target.closest('tr.clickable-row');
          if (row) {
            const name = row.dataset.name;
            this._showContextMenu(e, name);
          }
        });
      }

      // Skryj menu při kliknutí kamkoliv jinam (funguje pro obě verze)
      document.addEventListener('click', () => this._hideContextMenu());
      Modal.lockBackdrop(['generatorModal', 'editModal']);
    },

    init() {
      this.gen = new GeneratorController();
      this.edit = new EditorController();
      this._createContextMenu();
      this.bind();
      this.loadList();
    }
  };

  // ====== Start ======
  window.addEventListener('DOMContentLoaded', ()=> ProfilesPage.init());
})();
